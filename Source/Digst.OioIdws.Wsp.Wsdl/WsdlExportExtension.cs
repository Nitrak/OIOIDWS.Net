/*******************************************************************************
 * 
 * This project, Digst.OioIdws.Wsp.Wsdl, should only be referenced by the 
 * Digst.OioIdws.Wsp project as the main purpouse of this project is to provide
 * cross-platform ServiceMetadata (WSDL).
 * 
 * The project mainly consist of a class (WsdlExportExtension) which implements
 * two interfaces:
 * - IContractBehavior:
 *   Allows to update ServiceContract operations on service start (once)
 * - IWsdlExportExtension:
 *   Provides a customized and static (cached after first call) ServiceMetadata
 *   (WSDL) with the desired changes
 * 
 * It's higly recommended to read the following MSDN blog post before 
 * refactoring code as this implementation is heavily inspired in it:
 *  
 *  "WCF Extensibility – WSDL Export Extension – Carlos Figueira MSDN blog"
 *  https://blogs.msdn.microsoft.com/carlosfigueira/2011/10/05/wcf-extensibility-wsdl-export-extension/
 *  
 * The logic provided by this project goes beyond the blog post at we try to
 * comply with the requirements of providing a WSDL file that can be consumed
 * by other frameworks besides .NET without any local manual changes.
 * 
 * A few implementation details:
 * - We re-use about 85% of the standard WSDL which is generated by WCF
 * - We ensure that both "?singleWsdl" and "?wsdl" serve the same custom 
 *   generated WSDL
 * - We have statically added the most used namespaces: WSDL, SOAP 1.2, SAML, OASIS, ...
 *   in order to make the generated WSDL more readable
 * - We only modify the `Main Policy` but as with the WSDL, we re-use 85% of
 *   the policy which is generated by WCF based on the services App.config. We
 *   just need to ensure that the following three sections are in the generated
 *   WSDL:
 *   
 *     a) TransportBinding, see AuxTransportBinding in Policies.cs
 *     b) AsymmetricBinding, see AuxAsymmetricBinding in Policies.cs
 *     c) SignedSupportingTokens, see AuxSignedSupportingTokens in Policies.cs
 *     
 * - With regard of Policies.cs, we have tried to mimic the way all the rest of
 *   the sections are generated by WCF (type safety as well as hierarchical 
 *   structure).
 *   
 * REMARK: This is not intuitive, but `Policy` attribue namespaces MUST not be
 * set on the property itself [XmlElement] but on the class level [XmlType] as
 * this value must be inherited otherwise the the built-in .NET serializer will 
 * complain (error) about different types to represent the same XML tag.
 * 
 ******************************************************************************/

namespace Digst.OioIdws.Wsp.Wsdl
{
    using System;
    using System.Collections.Generic;
    using System.Net.Security;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Description;
    using System.ServiceModel.Dispatcher;
    using System.Xml;
    using System.Xml.Schema;

    using WSD = System.Web.Services.Description;

    using Element = Utils.Parse.Element;
    using Policy = Bindings.Policy;

    public sealed class WsdlExportExtension :
            Attribute, IContractBehavior, IWsdlExportExtension
    {
        TokenType token = TokenType.HolderOfKey;

        /// <summary>
        /// Default value is HolderOfKey
        /// </summary>
        public TokenType Token
        {
            get { return token; }
            set { token = value; }
        }

        #region Empty

        public void AddBindingParameters(
            ContractDescription contractDescription,
            ServiceEndpoint endpoint,
            BindingParameterCollection bindingParameters)
        { }

        public void ApplyClientBehavior(
            ContractDescription contractDescription,
            ServiceEndpoint endpoint,
            ClientRuntime clientRuntime)
        { }

        public void Validate(
            ContractDescription contractDescription,
            ServiceEndpoint endpoint)
        { }

        public void ExportContract(
            WsdlExporter exporter,
            WsdlContractConversionContext context)
        { }

        #endregion

        public void ApplyDispatchBehavior(
            ContractDescription contractDescription,
            ServiceEndpoint endpoint,
            DispatchRuntime dispatchRuntime)
        {
            foreach (OperationDescription operation in contractDescription.Operations)
            {
                // If not already maximum security (Sign + Encrypt)
                if (!operation.ProtectionLevel.Equals(ProtectionLevel.EncryptAndSign))
                {
                    // Ensure that all SOAP messages are at least signed
                    operation.ProtectionLevel = ProtectionLevel.Sign;
                }

                // Checking that SOAP faults can be read. SOAP faults are
                // encrypted in Sign and EncryptAndSign mode if no special care
                // is taken (standard .NET).
                //
                // Therefore, as SOAP messages are always at least signed, se
                // above, Fault messages will always be signed + encrypted:
                foreach (var fault in operation.Faults)
                {
                    fault.ProtectionLevel = ProtectionLevel.EncryptAndSign;
                }
            }
        }

        public void ExportEndpoint(
            WsdlExporter exporter,
            WsdlEndpointConversionContext context)
        {
            var wsdl = exporter.GeneratedWsdlDocuments[0];
            var schemas = exporter.GeneratedXmlSchemas;

            // In order to make generated WSDL more readable, common SOAP + SAML
            // namespaces are added to the head of the WSDL file
            var namespaces =
                Utils.Namespaces.Merge(
                    wsdl.Namespaces.ToArray(),
                    Utils.Namespaces.Required
                );

            var mainPolicy = new List<Element>();
            var mainPolicyName = context.WsdlBinding.Name + "_policy";
            if (wsdl.Extensions[0] is XmlElement policy)
            {
                mainPolicy.Add(Utils.Parse.Extension.Policy(policy));
            }

            // In order to ensure we always get the same WSDL even if we choose
            // ?singleWsdl or ?wsdl which limits the possibilities of errors.
            ClearTypes(wsdl);
            ClearMainPolicy(wsdl, mainPolicyName);

            AddNamespaces(wsdl, namespaces);
            AddTypes(wsdl, schemas);
            AddPoliciesMain(wsdl, mainPolicyName, mainPolicy, token);
        }

        private void ClearTypes(WSD.ServiceDescription wsdl)
        {
            wsdl.Types = new WSD.Types();
        }
        private void ClearMainPolicy(WSD.ServiceDescription wsdl, string name)
        {
            for (int i = wsdl.Extensions.Count - 1; i >= 0; i--)
            {
                if (wsdl.Extensions[i] is XmlElement extension &&
                    extension.LocalName == "Policy")
                {
                    foreach (XmlAttribute attrib in extension.Attributes)
                    {
                        if(attrib.LocalName.ToLower().Equals("id"))
                        {
                            if(attrib.Value.Equals(name))
                            {
                                wsdl.Extensions.RemoveAt(i);
                            }
                        }
                    }
                }
            }
        }

        private void AddNamespaces(
            WSD.ServiceDescription wsdl, 
            Dictionary<string, string> namespaces)
        {
            foreach (var ns in namespaces)
            {
                wsdl.Namespaces.Add(ns.Key, ns.Value);
            }
        }
        private void AddTypes(
            WSD.ServiceDescription wsdl,
            XmlSchemaSet schemas)
        {
            foreach (XmlSchema schema in schemas.Schemas())
            {
                wsdl.Types.Schemas.Add(schema);
            }
        }
        private void AddPoliciesMain(
            WSD.ServiceDescription wsdl,
            string contractName,
            List<Element> mainPolicy,
            TokenType token)
        {
            foreach (var p in mainPolicy)
            {
                if(Utils.Policies.Main(p, contractName, token) is Policy policy)
                {
                    wsdl.Extensions.Add(policy);
                }
            }
        }

        #region DEBUG

        private void AddMinimum(
            WSD.ServiceDescription wsdl,
            string contractName,
            OperationDescriptionCollection operations,
            ServiceEndpoint endpoint)
        {
            // Absolut minimum in order to provide a WSDL
            var portType =
                new WSD.PortType
                {
                    Name = contractName
                };
            wsdl.PortTypes.Add(portType);
            var address =
                new WSD.Soap12AddressBinding
                {
                    Location = endpoint.Address.ToString()
                };
            var port =
                new WSD.Port
                {
                    Name = contractName
                };
            port.Extensions.Add(address);
            var service =
                new WSD.Service
                {
                    Name = wsdl.Name
                };
            service.Ports.Add(port);
            wsdl.Services.Add(service);
        }

        #endregion
    }
}